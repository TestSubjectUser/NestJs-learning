1Ô∏è‚É£ Create an orphan branch git checkout --orphan empty-branch Creates a new branch without history
2Ô∏è‚É£ Remove files (optional) git rm -rf . Clears all tracked files
3Ô∏è‚É£ Create an empty commit (optional) git commit --allow-empty -m "Initial empty commit" Required if pushing to remote
4Ô∏è‚É£ Push branch (optional) git push origin empty-branch Pushes the branch to the remote
5Ô∏è‚É£ Verify branch git branch Checks branch existence

---

Add MongoDB's GPG key
Add the MongoDB repository
Update package list
Install MongoDB
Start and enable MongoDB service
Verify and connect to MongoDB

---

## have to perform all this tasks to connect with local mongodb

nest new . --skip-git

Robo 3T | Free, open-source MongoDB GUI (formerly Robomongo)
install create connection with name local > save.

install graphql dependencies
yarn add graphql graphql-tools apollo-server-express @nestjs/graphql

yarn add @nestjs/apollo
yarn add @apollo/server

nest g module lesson

defining the lesson GraphQL type
ObjectType with types named lesson, four fields, ID field is type of ID

creating the lesson resolver
Resolvers are the core of how GraphQL works in NestJS. They handle queries, mutations, and subscriptions by fetching data from a database or another source.

@Resolver(() => LessonType): Specifies that this resolver handles LessonType queries.
Without resolvers, GraphQL would not know how to respond to API requests.

Every resolver is just a service that provides data. In NestJS, we must register services in the providers array so that NestJS can inject and manage them.

we can visit http://localhost:3000/graphql if server is running, check out schema

TypeORM MongoDB and Lesson Entity
yarn add typeorm @nestjs/typeorm mongodb @types/mongodb

LessonService and createLesson
nest g service lesson --no-spec

yarn add uuid

create lesson graphql mutation

add mutation with graphql

```mutation{
  createLesson(
    name: "Khushal name 1"
    startDate: "2020-03-28T18:00:00Z"
    endDate: "2020-03-28T18:00:00Z"
  ){
    name
  }
}
```

now we can see it in our localhost robo3t that mutation has happened

getLesson, create lesson input
Validation, create lesson input

npm install class-validator class-transformer

Decorator that marks a class as a GraphQL input type.
@Field() decorator is used to mark a specific class property as a GraphQL field. Only properties decorated with this decorator will be defined in the schema.

```graphql
mutation {
  createLesson(
    createLessonInput: {
      name: "someName"
      startDate: "2025-02-28T18:00:00Z"
      endDate: "2025-02-28T18:00:00Z"
    }
  ) {
    name
  }
}
# query{
# 	lesson(id: "ac40204e-449d-4293-b906-a83ba0862268"){
#     id
#     name
#     startDate
#     endDate
#   }
# }
```

Get All Lessons

Student module
nest g module student
nest g service student --no-spec

INFO:
Why do we use TypeOrmModule.forFeature([Student]) in StudentModule?
TypeOrmModule.forRoot(...) in AppModule sets up the global database connection for the entire NestJS application.
However, NestJS follows a modular structure, so each module should only access the entities relevant to it.
TypeOrmModule.forFeature([Student]) registers the Student entity within StudentModule, allowing dependency injection of Repository<Student>.

üîπ Why can't we access StudentRepository directly without forFeature?
NestJS lazy-loads dependencies and scopes repositories to specific modules for better organization.

‚úÖ TypeOrmModule.forFeature([Student]) ensures that NestJS injects the repository only within StudentModule.
Without this, the StudentService wouldn't have access to Repository<Student>.

üîπ Difference between forRoot() and forFeature()
Method Purpose
TypeOrmModule.forRoot({...}) Establishes the database connection globally. Used in AppModule.
TypeOrmModule.forFeature([...]) Registers specific entities in a module, making their repositories available via dependency injection. Used in feature modules like StudentModule.

Now, studentRepository can be injected into StudentService and used to interact with the database.

@Args('createStudentInput') createStudentInput: CreateStudentInput

The @Args('createStudentInput') tells NestJS to extract the argument named createStudentInput from the GraphQL request payload.
The createStudentInput: CreateStudentInput ensures TypeScript knows the expected shape of the argument.

// It extracts the createStudentInput argument from the GraphQL request.
// It validates that the received data matches the CreateStudentInput type.
// It ensures that only the expected fields are passed, avoiding extra/unwanted data.

```graphql
# mutation{
#   createStudent(createStudentInput:{
#     firstname: "fname1", lastname:"fname2"
#   }){
#     id
#   }
# }
query {
  getStudents {
    id
    firstname
    lastname
  }
}
query {
  getStudent(id: "9c0d8b58-0216-4a79-bd38-d319b19e1644") {
    id
    firstname
    lastname
  }
}
```

Assign Students to lesson graphql mutation

lesson.type.ts (GraphQL Representation)
This file defines the GraphQL object type that determines how the Lesson entity is exposed in the GraphQL schema.

lesson.entity.ts (Database Representation)
This file defines the actual database structure for storing Lesson data using TypeORM.

```graphql
mutation {
  createLesson(
    createLessonInput: {
      name: "Docker"
      startDate: "2025-02-26T18:00:00Z"
      endDate: "2025-03-02T18:00:00Z"
    }
  ) {
    id
  }
}
mutation {
  createStudent(
    createStudentInput: { firstname: "studentFN2", lastname: "studentLN2" }
  ) {
    id
  }
}
mutation {
  assignLessonToStudents(
    assignStudentsToLessonInput: {
      lessonId: "83658cb5-9fe0-4f9c-95ce-f521de9e6bbd"
      studentIds: [
        "fcef9bd0-06d0-4379-a3a6-d88f7793c1c6"
        "6209e3d3-946e-4694-b963-98fb34454fbe"
      ]
    }
  ) {
    name
  }
}
```

we're providing empty array initially in lesson.students,
improvement - assign students upon lesson creation

```graphql
mutation {
  createLesson(
    createLessonInput: {
      name: "KubernetesWithStudents"
      startDate: "2025-02-26T18:00:00Z"
      endDate: "2025-03-02T18:00:00Z"
      students: [
        "6209e3d3-946e-4694-b963-98fb34454fbe"
        "fcef9bd0-06d0-4379-a3a6-d88f7793c1c6"
      ]
    }
  ) {
    id
    name
  }
}

mutation {
  createLesson(
    createLessonInput: {
      name: "KubernetesWithNoStudents"
      startDate: "2025-02-26T18:00:00Z"
      endDate: "2025-03-02T18:00:00Z"
      students: []
    }
  ) {
    id
    name
  }
}
```

resolve - students field in lesson

now when we add firstname, lastname inside students return query it will give error

```graphql
mutation {
  createLesson(
    createLessonInput: {
      name: "KubernetesWithStudents123"
      startDate: "2025-02-26T18:00:00Z"
      endDate: "2025-03-02T18:00:00Z"
      students: [
        "6209e3d3-946e-4694-b963-98fb34454fbe"
        "fcef9bd0-06d0-4379-a3a6-d88f7793c1c6"
      ]
    }
  ) {
    students {
      firstname
      lastname
    }
  }
}
```

the @ResolveField decorator is used to define resolvers for fields that are not directly fetched from the database or require additional computation or transformation before being returned. This decorator is essential for handling derived data or fetching related data in a GraphQL schema.

@ResolveField() is used to dynamically resolve a field in a GraphQL type.

```javascript
@ResolveField()
async students(@Parent() lesson: LessonType) {
  // Fetch students based on lesson.students (array of student IDs)
}
```

Here‚Äôs what happens:

The LessonType has a students field, but in your database (lesson.entity.ts), it's just an array of student IDs (students: string[]).
The resolver function retrieves the actual Student objects based on those IDs.
GraphQL will call this resolver only when a query requests the students field.

the function name must match the field name

1Ô∏è‚É£ The Role of @Parent() in GraphQL Resolvers
When you define a @ResolveField() in a NestJS GraphQL resolver, you're telling NestJS to handle the resolution of that field. However, the @ResolveField() decorator doesn't automatically know the parent object of the field. The parent object is essentially the data returned by the parent query, in your case, the LessonType object.

2Ô∏è‚É£ What Happens Behind the Scenes?
When a GraphQL query is made, NestJS uses the following process:

The query hits the main resolver, for example, getLesson(id: "123").
NestJS executes the corresponding resolver method (getLesson in your case).
NestJS resolves the LessonType object and hands it over as the parent data to the resolver.
When the students field is requested, NestJS calls the students resolver method.
The @Parent() decorator is used to access the parent object (the LessonType object).
You use this parent object to access its properties, like the students field, which contains the student IDs.

6Ô∏è‚É£ Conclusion
The @Parent() decorator is required because the resolver needs access to the parent object (lesson) to resolve the field (students).
GraphQL does not automatically pass the parent data to the resolver ‚Äî the @Parent() decorator provides this.
Without @Parent(), the resolver wouldn‚Äôt know which lesson‚Äôs students it should resolve.

now below query will work...
```graphql
mutation{
  createLesson(createLessonInput: {
    name: "KubernetesWithStudents123asd"
    startDate: "2025-02-26T18:00:00Z"
    endDate: "2025-03-02T18:00:00Z"
    students: [
      "6209e3d3-946e-4694-b963-98fb34454fbe",
      "fcef9bd0-06d0-4379-a3a6-d88f7793c1c6"
    ]
  }){
    id
    name
    startDate
    endDate
    students{
			firstname
      lastname
    }
  }
}
```
