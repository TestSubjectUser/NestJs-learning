1️⃣ Create an orphan branch git checkout --orphan empty-branch Creates a new branch without history
2️⃣ Remove files (optional) git rm -rf . Clears all tracked files
3️⃣ Create an empty commit (optional) git commit --allow-empty -m "Initial empty commit" Required if pushing to remote
4️⃣ Push branch (optional) git push origin empty-branch Pushes the branch to the remote
5️⃣ Verify branch git branch Checks branch existence

---

Add MongoDB's GPG key
Add the MongoDB repository
Update package list
Install MongoDB
Start and enable MongoDB service
Verify and connect to MongoDB

---

## have to perform all this tasks to connect with local mongodb

nest new . --skip-git

Robo 3T | Free, open-source MongoDB GUI (formerly Robomongo)
install create connection with name local > save.

install graphql dependencies
yarn add graphql graphql-tools apollo-server-express @nestjs/graphql

yarn add @nestjs/apollo
yarn add @apollo/server

nest g module lesson

defining the lesson GraphQL type
ObjectType with types named lesson, four fields, ID field is type of ID

creating the lesson resolver
Resolvers are the core of how GraphQL works in NestJS. They handle queries, mutations, and subscriptions by fetching data from a database or another source.

@Resolver(() => LessonType): Specifies that this resolver handles LessonType queries.
Without resolvers, GraphQL would not know how to respond to API requests.

Every resolver is just a service that provides data. In NestJS, we must register services in the providers array so that NestJS can inject and manage them.

we can visit http://localhost:3000/graphql if server is running, check out schema

TypeORM MongoDB and Lesson Entity
yarn add typeorm @nestjs/typeorm mongodb @types/mongodb

LessonService and createLesson
nest g service lesson --no-spec

yarn add uuid

create lesson graphql mutation

add mutation with graphql

```mutation{
  createLesson(
    name: "Khushal name 1"
    startDate: "2020-03-28T18:00:00Z"
    endDate: "2020-03-28T18:00:00Z"
  ){
    name
  }
}
```

now we can see it in our localhost robo3t that mutation has happened

getLesson, create lesson input
Validation, create lesson input

npm install class-validator class-transformer

Decorator that marks a class as a GraphQL input type.
@Field() decorator is used to mark a specific class property as a GraphQL field. Only properties decorated with this decorator will be defined in the schema.

```graphql
mutation {
  createLesson(
    createLessonInput: {
      name: "someName"
      startDate: "2025-02-28T18:00:00Z"
      endDate: "2025-02-28T18:00:00Z"
    }
  ) {
    name
  }
}
# query{
# 	lesson(id: "ac40204e-449d-4293-b906-a83ba0862268"){
#     id
#     name
#     startDate
#     endDate
#   }
# }
```

Get All Lessons

Student module
nest g module student
nest g service student --no-spec

INFO:
Why do we use TypeOrmModule.forFeature([Student]) in StudentModule?
TypeOrmModule.forRoot(...) in AppModule sets up the global database connection for the entire NestJS application.
However, NestJS follows a modular structure, so each module should only access the entities relevant to it.
TypeOrmModule.forFeature([Student]) registers the Student entity within StudentModule, allowing dependency injection of Repository<Student>.

🔹 Why can't we access StudentRepository directly without forFeature?
NestJS lazy-loads dependencies and scopes repositories to specific modules for better organization.

✅ TypeOrmModule.forFeature([Student]) ensures that NestJS injects the repository only within StudentModule.
Without this, the StudentService wouldn't have access to Repository<Student>.

🔹 Difference between forRoot() and forFeature()
Method Purpose
TypeOrmModule.forRoot({...}) Establishes the database connection globally. Used in AppModule.
TypeOrmModule.forFeature([...]) Registers specific entities in a module, making their repositories available via dependency injection. Used in feature modules like StudentModule.

Now, studentRepository can be injected into StudentService and used to interact with the database.

@Args('createStudentInput') createStudentInput: CreateStudentInput

The @Args('createStudentInput') tells NestJS to extract the argument named createStudentInput from the GraphQL request payload.
The createStudentInput: CreateStudentInput ensures TypeScript knows the expected shape of the argument.

// It extracts the createStudentInput argument from the GraphQL request.
// It validates that the received data matches the CreateStudentInput type.
// It ensures that only the expected fields are passed, avoiding extra/unwanted data.

```graphql
# mutation{
#   createStudent(createStudentInput:{
#     firstname: "fname1", lastname:"fname2"
#   }){
#     id
#   }
# }
query {
  getStudents {
    id
    firstname
    lastname
  }
}
query {
  getStudent(id: "9c0d8b58-0216-4a79-bd38-d319b19e1644") {
    id
    firstname
    lastname
  }
}
```
